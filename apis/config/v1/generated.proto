/*
Copyright 2024 The olive Authors

This program is offered under a commercial and under the AGPL license.
For AGPL licensing, see below.

AGPL licensing:
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.olive_io.olive.apis.config.v1;

import "github.com/olive-io/olive/apis/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "github.com/olive-io/olive/apis/config/v1";

// DefaultPreemptionArgs holds arguments used to configure the
// DefaultPreemption plugin.
message DefaultPreemptionArgs {
  // MinCandidateRunnersPercentage is the minimum number of candidates to
  // shortlist when dry running preemption as a percentage of number of runners.
  // Must be in the range [0, 100]. Defaults to 10% of the cluster size if
  // unspecified.
  optional int32 minCandidateRunnersPercentage = 1;

  // MinCandidateRunnersAbsolute is the absolute minimum number of candidates to
  // shortlist. The likely number of candidates enumerated for dry running
  // preemption is given by the formula:
  // numCandidates = max(numRunners * minCandidateRunnersPercentage, minCandidateRunnersAbsolute)
  // We say "likely" because there are other factors such as PDB violations
  // that play a role in the number of candidates shortlisted. Must be at least
  // 0 runners. Defaults to 100 runners if unspecified.
  optional int32 minCandidateRunnersAbsolute = 2;
}

// Extender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
// it is assumed that the extender chose not to provide that extension.
message Extender {
  // URLPrefix at which the extender is available
  optional string urlPrefix = 1;

  // Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.
  optional string filterVerb = 2;

  // Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.
  optional string preemptVerb = 3;

  // Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.
  optional string prioritizeVerb = 4;

  // The numeric multiplier for the runner scores that the prioritize call generates.
  // The weight should be a positive integer
  optional int64 weight = 5;

  // Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
  // If this method is implemented by the extender, it is the extender's responsibility to bind the region to apiserver. Only one extender
  // can implement this function.
  optional string bindVerb = 6;

  // EnableHTTPS specifies whether https should be used to communicate with the extender
  optional bool enableHTTPS = 7;

  // TLSConfig specifies the transport layer security config
  optional ExtenderTLSConfig tlsConfig = 8;

  // HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the region. Prioritize
  // timeout is ignored, k8s/other extenders priorities are used to select the runner.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration httpTimeout = 9;

  // RunnerCacheCapable specifies that the extender is capable of caching runner information,
  // so the scheduler should only send minimal information about the eligible runners
  // assuming that the extender already cached full details of all runners in the cluster
  optional bool runnerCacheCapable = 10;

  // ManagedResources is a list of extended resources that are managed by
  // this extender.
  // - A region will be sent to the extender on the Filter, Prioritize and Bind
  //   (if the extender is the binder) phases iff the region requests at least
  //   one of the extended resources in this list. If empty or unspecified,
  //   all regions will be sent to this extender.
  // - If IgnoredByScheduler is set to true for a resource, kube-scheduler
  //   will skip checking the resource in predicates.
  // +optional
  // +listType=atomic
  repeated ExtenderManagedResource managedResources = 11;

  // Ignorable specifies if the extender is ignorable, i.e. scheduling should not
  // fail when the extender returns an error or is not reachable.
  optional bool ignorable = 12;
}

// ExtenderManagedResource describes the arguments of extended resources
// managed by an extender.
message ExtenderManagedResource {
  // Name is the extended resource name.
  optional string name = 1;

  // IgnoredByScheduler indicates whether kube-scheduler should ignore this
  // resource when applying predicates.
  optional bool ignoredByScheduler = 2;
}

// ExtenderTLSConfig contains settings to enable TLS with extender
message ExtenderTLSConfig {
  // Server should be accessed without verifying the TLS certificate. For testing only.
  optional bool insecure = 1;

  // ServerName is passed to the server for SNI and is used in the client to check server
  // certificates against. If ServerName is empty, the hostname used to contact the
  // server is used.
  optional string serverName = 2;

  // Server requires TLS client certificate authentication
  optional string certFile = 3;

  // Server requires TLS client certificate authentication
  optional string keyFile = 4;

  // Trusted root certificates for server
  optional string caFile = 5;

  // CertData holds PEM-encoded bytes (typically read from a client certificate file).
  // CertData takes precedence over CertFile
  // +listType=atomic
  optional bytes certData = 6;

  // KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
  // KeyData takes precedence over KeyFile
  // +listType=atomic
  optional bytes keyData = 7;

  // CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
  // CAData takes precedence over CAFile
  // +listType=atomic
  optional bytes caData = 8;
}

// InterRegionAffinityArgs holds arguments used to configure the InterRegionAffinity plugin.
message InterRegionAffinityArgs {
  // HardRegionAffinityWeight is the scoring weight for existing regions with a
  // matching hard affinity to the incoming region.
  optional int32 hardRegionAffinityWeight = 1;

  // IgnorePreferredTermsOfExistingRegions configures the scheduler to ignore existing regions' preferred affinity
  // rules when scoring candidate runners, unless the incoming region has inter-region affinities.
  optional bool ignorePreferredTermsOfExistingRegions = 2;
}

// Plugin specifies a plugin name and its weight when applicable. Weight is used only for Score plugins.
message Plugin {
  // Name defines the name of plugin
  optional string name = 1;

  // Weight defines the weight of plugin, only used for Score plugins.
  optional int32 weight = 2;
}

// PluginConfig specifies arguments that should be passed to a plugin at the time of initialization.
// A plugin that is invoked at multiple extension points is initialized once. Args can have arbitrary structure.
// It is up to the plugin to process these Args.
message PluginConfig {
  // Name defines the name of plugin being configured
  optional string name = 1;

  // Args defines the arguments passed to the plugins at the time of initialization. Args can have arbitrary structure.
  optional k8s.io.apimachinery.pkg.runtime.RawExtension args = 2;
}

// PluginSet specifies enabled and disabled plugins for an extension point.
// If an array is empty, missing, or nil, default plugins at that extension point will be used.
message PluginSet {
  // Enabled specifies plugins that should be enabled in addition to default plugins.
  // If the default plugin is also configured in the scheduler config file, the weight of plugin will
  // be overridden accordingly.
  // These are called after default plugins and in the same order specified here.
  // +listType=atomic
  repeated Plugin enabled = 1;

  // Disabled specifies default plugins that should be disabled.
  // When all default plugins need to be disabled, an array containing only one "*" should be provided.
  // +listType=map
  // +listMapKey=name
  repeated Plugin disabled = 2;
}

// Plugins include multiple extension points. When specified, the list of plugins for
// a particular extension point are the only ones enabled. If an extension point is
// omitted from the config, then the default set of plugins is used for that extension point.
// Enabled plugins are called in the order specified here, after default plugins. If they need to
// be invoked before default plugins, default plugins must be disabled and re-enabled here in desired order.
message Plugins {
  // PreEnqueue is a list of plugins that should be invoked before adding regions to the scheduling queue.
  optional PluginSet preEnqueue = 1;

  // QueueSort is a list of plugins that should be invoked when sorting regions in the scheduling queue.
  optional PluginSet queueSort = 2;

  // PreFilter is a list of plugins that should be invoked at "PreFilter" extension point of the scheduling framework.
  optional PluginSet preFilter = 3;

  // Filter is a list of plugins that should be invoked when filtering out runners that cannot run the Region.
  optional PluginSet filter = 4;

  // PostFilter is a list of plugins that are invoked after filtering phase, but only when no feasible runners were found for the region.
  optional PluginSet postFilter = 5;

  // PreScore is a list of plugins that are invoked before scoring.
  optional PluginSet preScore = 6;

  // Score is a list of plugins that should be invoked when ranking runners that have passed the filtering phase.
  optional PluginSet score = 7;

  // Reserve is a list of plugins invoked when reserving/unreserving resources
  // after a runner is assigned to run the region.
  optional PluginSet reserve = 8;

  // Permit is a list of plugins that control binding of a Region. These plugins can prevent or delay binding of a Region.
  optional PluginSet permit = 9;

  // PreBind is a list of plugins that should be invoked before a region is bound.
  optional PluginSet preBind = 10;

  // Bind is a list of plugins that should be invoked at "Bind" extension point of the scheduling framework.
  // The scheduler call these plugins in order. Scheduler skips the rest of these plugins as soon as one returns success.
  optional PluginSet bind = 11;

  // PostBind is a list of plugins that should be invoked after a region is successfully bound.
  optional PluginSet postBind = 12;

  // MultiPoint is a simplified config section to enable plugins for all valid extension points.
  // Plugins enabled through MultiPoint will automatically register for every individual extension
  // point the plugin has implemented. Disabling a plugin through MultiPoint disables that behavior.
  // The same is true for disabling "*" through MultiPoint (no default plugins will be automatically registered).
  // Plugins can still be disabled through their individual extension points.
  //
  // In terms of precedence, plugin config follows this basic hierarchy
  //   1. Specific extension points
  //   2. Explicitly configured MultiPoint plugins
  //   3. The set of default plugins, as MultiPoint plugins
  // This implies that a higher precedence plugin will run first and overwrite any settings within MultiPoint.
  // Explicitly user-configured plugins also take a higher precedence over default plugins.
  // Within this hierarchy, an Enabled setting takes precedence over Disabled. For example, if a plugin is
  // set in both `multiPoint.Enabled` and `multiPoint.Disabled`, the plugin will be enabled. Similarly,
  // including `multiPoint.Disabled = '*'` and `multiPoint.Enabled = pluginA` will still register that specific
  // plugin through MultiPoint. This follows the same behavior as all other extension point configurations.
  optional PluginSet multiPoint = 13;
}

// RegionTopologySpreadArgs holds arguments used to configure the RegionTopologySpread plugin.
message RegionTopologySpreadArgs {
  // DefaultConstraints defines topology spread constraints to be applied to
  // regions that don't define any in `region.spec.topologySpreadConstraints`.
  // `.defaultConstraints[*].labelSelectors` must be empty, as they are
  // deduced from the region's membership to Services, ReplicationControllers,
  // ReplicaSets or StatefulSets.
  // When not empty, .defaultingType must be "List".
  // +optional
  // +listType=atomic
  repeated github.com.olive_io.olive.apis.core.v1.TopologySpreadConstraint defaultConstraints = 1;

  // DefaultingType determines how .defaultConstraints are deduced. Can be one
  // of "System" or "List".
  //
  // - "System": Use kubernetes defined constraints that spread regions among
  //   Runners and Zones.
  // - "List": Use constraints defined in .defaultConstraints.
  //
  // Defaults to "System".
  // +optional
  optional string defaultingType = 2;
}

// RequestedToCapacityRatioParam define RequestedToCapacityRatio parameters
message RequestedToCapacityRatioParam {
  // Shape is a list of points defining the scoring function shape.
  // +listType=atomic
  repeated UtilizationShapePoint shape = 1;
}

// ResourceSpec represents a single resource.
message ResourceSpec {
  // Name of the resource.
  optional string name = 1;

  // Weight of the resource.
  optional int64 weight = 2;
}

// RunnerAffinityArgs holds arguments to configure the RunnerAffinity plugin.
message RunnerAffinityArgs {
  // AddedAffinity is applied to all regions additionally to the RunnerAffinity
  // specified in the regionSpec. That is, Runners need to satisfy AddedAffinity
  // AND .spec.RunnerAffinity. AddedAffinity is empty by default (all Runners
  // match).
  // When AddedAffinity is used, some regions with affinity requirements that match
  // a specific Runner (such as Daemonset regions) might remain unschedulable.
  // +optional
  optional github.com.olive_io.olive.apis.core.v1.RunnerAffinity addedAffinity = 1;
}

// RunnerResourcesBalancedAllocationArgs holds arguments used to configure RunnerResourcesBalancedAllocation plugin.
message RunnerResourcesBalancedAllocationArgs {
  // Resources to be managed, the default is "cpu" and "memory" if not specified.
  // +listType=map
  // +listMapKey=name
  repeated ResourceSpec resources = 1;
}

// RunnerResourcesFitArgs holds arguments used to configure the RunnerResourcesFit plugin.
message RunnerResourcesFitArgs {
  // IgnoredResources is the list of resources that RunnerResources fit filter
  // should ignore. This doesn't apply to scoring.
  // +listType=atomic
  repeated string ignoredResources = 1;

  // IgnoredResourceGroups defines the list of resource groups that RunnerResources fit filter should ignore.
  // e.g. if group is ["example.com"], it will ignore all resource names that begin
  // with "example.com", such as "example.com/aaa" and "example.com/bbb".
  // A resource group name can't contain '/'. This doesn't apply to scoring.
  // +listType=atomic
  repeated string ignoredResourceGroups = 2;

  // ScoringStrategy selects the runner resource scoring strategy.
  // The default strategy is LeastAllocated with an equal "cpu" and "memory" weight.
  optional ScoringStrategy scoringStrategy = 3;
}

// SchedulerConfiguration configures a scheduler
message SchedulerConfiguration {
  // Parallelism defines the amount of parallelism in algorithms for scheduling a Regions. Must be greater than 0. Defaults to 16
  optional int32 parallelism = 1;

  // LeaderElection defines the configuration of leader election client.
  optional LeaderElectionConfiguration leaderElection = 2;

  // ClientConnection specifies the kubeconfig file and client connection
  // settings for the proxy server to use when communicating with the apiserver.
  optional ClientConnectionConfiguration clientConnection = 3;

  // DebuggingConfiguration holds configuration for Debugging related features
  // TODO: We might wanna make this a substruct like Debugging componentbaseconfigv1alpha1.DebuggingConfiguration
  optional DebuggingConfiguration debuggingConfiguration = 4;

  // PercentageOfRunnersToScore is the percentage of all runners that once found feasible
  // for running a region, the scheduler stops its search for more feasible runners in
  // the cluster. This helps improve scheduler's performance. Scheduler always tries to find
  // at least "minFeasibleRunnersToFind" feasible runners no matter what the value of this flag is.
  // Example: if the cluster size is 500 runners and the value of this flag is 30,
  // then scheduler stops finding further feasible runners once it finds 150 feasible ones.
  // When the value is 0, default percentage (5%--50% based on the size of the cluster) of the
  // runners will be scored. It is overridden by profile level PercentageofRunnersToScore.
  optional int32 percentageOfRunnersToScore = 5;

  // RegionInitialBackoffSeconds is the initial backoff for unschedulable regions.
  // If specified, it must be greater than 0. If this value is null, the default value (1s)
  // will be used.
  optional int64 regionInitialBackoffSeconds = 6;

  // RegionMaxBackoffSeconds is the max backoff for unschedulable regions.
  // If specified, it must be greater than regionInitialBackoffSeconds. If this value is null,
  // the default value (10s) will be used.
  optional int64 regionMaxBackoffSeconds = 7;

  // Profiles are scheduling profiles that kube-scheduler supports. Regions can
  // choose to be scheduled under a particular profile by setting its associated
  // scheduler name. Regions that don't specify any scheduler name are scheduled
  // with the "default-scheduler" profile, if present here.
  // +listType=map
  // +listMapKey=schedulerName
  repeated SchedulerProfile profiles = 8;

  // Extenders are the list of scheduler extenders, each holding the values of how to communicate
  // with the extender. These extenders are shared by all scheduler profiles.
  // +listType=set
  repeated Extender extenders = 9;

  // DelayCacheUntilActive specifies when to start caching. If this is true and leader election is enabled,
  // the scheduler will wait to fill informer caches until it is the leader. Doing so will have slower
  // failover with the benefit of lower memory overhead while waiting to become leader.
  // Defaults to false.
  optional bool delayCacheUntilActive = 10;
}

// SchedulerProfile is a scheduling profile.
message SchedulerProfile {
  // SchedulerName is the name of the scheduler associated to this profile.
  // If SchedulerName matches with the region's "spec.schedulerName", then the region
  // is scheduled with this profile.
  optional string schedulerName = 1;

  // PercentageOfRunnersToScore is the percentage of all runners that once found feasible
  // for running a region, the scheduler stops its search for more feasible runners in
  // the cluster. This helps improve scheduler's performance. Scheduler always tries to find
  // at least "minFeasibleRunnersToFind" feasible runners no matter what the value of this flag is.
  // Example: if the cluster size is 500 runners and the value of this flag is 30,
  // then scheduler stops finding further feasible runners once it finds 150 feasible ones.
  // When the value is 0, default percentage (5%--50% based on the size of the cluster) of the
  // runners will be scored. It will override global PercentageOfRunnersToScore. If it is empty,
  // global PercentageOfRunnersToScore will be used.
  optional int32 percentageOfRunnersToScore = 2;

  // Plugins specify the set of plugins that should be enabled or disabled.
  // Enabled plugins are the ones that should be enabled in addition to the
  // default plugins. Disabled plugins are any of the default plugins that
  // should be disabled.
  // When no enabled or disabled plugin is specified for an extension point,
  // default plugins for that extension point will be used if there is any.
  // If a QueueSort plugin is specified, the same QueueSort Plugin and
  // PluginConfig must be specified for all profiles.
  optional Plugins plugins = 3;

  // PluginConfig is an optional set of custom plugin arguments for each plugin.
  // Omitting config args for a plugin is equivalent to using the default config
  // for that plugin.
  // +listType=map
  // +listMapKey=name
  repeated PluginConfig pluginConfig = 4;
}

// ScoringStrategy define ScoringStrategyType for runner resource plugin
message ScoringStrategy {
  // Type selects which strategy to run.
  optional string type = 1;

  // Resources to consider when scoring.
  // The default resource set includes "cpu" and "memory" with an equal weight.
  // Allowed weights go from 1 to 100.
  // Weight defaults to 1 if not specified or explicitly set to 0.
  // +listType=map
  // +listMapKey=topologyKey
  repeated ResourceSpec resources = 2;

  // Arguments specific to RequestedToCapacityRatio strategy.
  optional RequestedToCapacityRatioParam requestedToCapacityRatio = 3;
}

// UtilizationShapePoint represents single point of priority function shape.
message UtilizationShapePoint {
  // Utilization (x axis). Valid values are 0 to 100. Fully utilized runner maps to 100.
  optional int32 utilization = 1;

  // Score assigned to given utilization (y axis). Valid values are 0 to 10.
  optional int32 score = 2;
}

// VolumeBindingArgs holds arguments used to configure the VolumeBinding plugin.
message VolumeBindingArgs {
  // BindTimeoutSeconds is the timeout in seconds in volume binding operation.
  // Value must be non-negative integer. The value zero indicates no waiting.
  // If this value is nil, the default value (600) will be used.
  optional int64 bindTimeoutSeconds = 1;

  // Shape specifies the points defining the score function shape, which is
  // used to score runners based on the utilization of statically provisioned
  // PVs. The utilization is calculated by dividing the total requested
  // storage of the region by the total capacity of feasible PVs on each runner.
  // Each point contains utilization (ranges from 0 to 100) and its
  // associated score (ranges from 0 to 10). You can turn the priority by
  // specifying different scores for different utilization numbers.
  // The default shape points are:
  // 1) 0 for 0 utilization
  // 2) 10 for 100 utilization
  // All points must be sorted in increasing order by utilization.
  // +featureGate=VolumeCapacityPriority
  // +optional
  // +listType=atomic
  repeated UtilizationShapePoint shape = 2;
}

message ClientConnectionConfiguration {
  // kubeconfig is the path to a KubeConfig file.
  optional string kubeconfig = 1;

  // acceptContentTypes defines the Accept header sent by clients when connecting to a server, overriding the
  // default value of 'application/json'. This field will control all connections to the server used by a particular
  // client.
  optional string acceptContentTypes = 2;

  // contentType is the content type used when sending data to the server from this client.
  optional string contentType = 3;

  // qps controls the number of queries per second allowed for this connection.
  optional float qPS = 4;

  // burst allows extra queries to accumulate when a client is exceeding its rate.
  optional int32 burst = 5;
}

message DebuggingConfiguration {
  // enableProfiling enables profiling via web interface host:port/debug/pprof/
  optional bool enableProfiling = 1;

  // enableContentionProfiling enables block profiling, if
  // enableProfiling is true.
  optional bool enableContentionProfiling = 2;
}

message LeaderElectionConfiguration {
  // leaderElect enables a leader election client to gain leadership
  // before executing the main loop. Enable this when running replicated
  // components for high availability.
  optional bool leaderElect = 1;

  // leaseDuration is the duration that non-leader candidates will wait
  // after observing a leadership renewal until attempting to acquire
  // leadership of a led but unrenewed leader slot. This is effectively the
  // maximum duration that a leader can be stopped before it is replaced
  // by another candidate. This is only applicable if leader election is
  // enabled.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration leaseDuration = 2;

  // renewDeadline is the interval between attempts by the acting master to
  // renew a leadership slot before it stops leading. This must be less
  // than or equal to the lease duration. This is only applicable if leader
  // election is enabled.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration renewDeadline = 3;

  // retryPeriod is the duration the clients should wait between attempting
  // acquisition and renewal of a leadership. This is only applicable if
  // leader election is enabled.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Duration retryPeriod = 4;

  // resourceLock indicates the resource object type that will be used to lock
  // during leader election cycles.
  optional string resourceLock = 5;

  // resourceName indicates the name of resource object that will be used to lock
  // during leader election cycles.
  optional string resourceName = 6;

  // resourceNamespace indicates the namespace of resource object that will be used to lock
  // during leader election cycles.
  optional string resourceNamespace = 7;
}

