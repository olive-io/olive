// Code generated by proto-gen-gogo. DO NOT EDIT.
// source: github.com/olive-io/olive/api/olivepb/internal.proto

package olivepb

import (
	ebinary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = ebinary.BigEndian

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

type State int32

const (
	State_UnKnown  State = 0
	State_Ready    State = 1
	State_NotReady State = 2
	State_Alarm    State = 3
)

var State_name = map[int32]string{
	0: "UnKnown",
	1: "Ready",
	2: "NotReady",
	3: "Alarm",
}

var State_value = map[string]int32{
	"UnKnown":  0,
	"Ready":    1,
	"NotReady": 2,
	"Alarm":    3,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}

func (State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{0}
}

type OliveHeader struct {
	Runner uint64 `protobuf:"varint,1,opt,name=runner,proto3" json:"runner,omitempty"`
	Region uint64 `protobuf:"varint,2,opt,name=region,proto3" json:"region,omitempty"`
	Rev    int64  `protobuf:"varint,3,opt,name=rev,proto3" json:"rev,omitempty"`
}

func (m *OliveHeader) Reset()         { *m = OliveHeader{} }
func (m *OliveHeader) String() string { return proto.CompactTextString(m) }
func (*OliveHeader) ProtoMessage()    {}
func (*OliveHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{0}
}
func (m *OliveHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OliveHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OliveHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OliveHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OliveHeader.Merge(m, src)
}
func (m *OliveHeader) XXX_Size() int {
	return m.XSize()
}
func (m *OliveHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_OliveHeader.DiscardUnknown(m)
}

var xxx_messageInfo_OliveHeader proto.InternalMessageInfo

type ResponseHeader struct {
	// cluster_id is the ID of the cluster which sent the response.
	ClusterId uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// member_id is the ID of the member which sent the response.
	MemberId uint64 `protobuf:"varint,2,opt,name=member_id,json=memberId,proto3" json:"member_id,omitempty"`
	// raft_term is the raft term when the request was applied.
	RaftTerm uint64 `protobuf:"varint,3,opt,name=raft_term,json=raftTerm,proto3" json:"raft_term,omitempty"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{1}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.XSize()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

type Meta struct {
	ClusterId uint64        `protobuf:"varint,1,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	Leader    uint64        `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
	Members   []*MetaMember `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *Meta) Reset()         { *m = Meta{} }
func (m *Meta) String() string { return proto.CompactTextString(m) }
func (*Meta) ProtoMessage()    {}
func (*Meta) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{2}
}
func (m *Meta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Meta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Meta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meta.Merge(m, src)
}
func (m *Meta) XXX_Size() int {
	return m.XSize()
}
func (m *Meta) XXX_DiscardUnknown() {
	xxx_messageInfo_Meta.DiscardUnknown(m)
}

var xxx_messageInfo_Meta proto.InternalMessageInfo

type MetaMember struct {
	Id         uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ClientURLs []string `protobuf:"bytes,2,rep,name=clientURLs,proto3" json:"clientURLs,omitempty"`
	PeerURLs   []string `protobuf:"bytes,3,rep,name=peerURLs,proto3" json:"peerURLs,omitempty"`
}

func (m *MetaMember) Reset()         { *m = MetaMember{} }
func (m *MetaMember) String() string { return proto.CompactTextString(m) }
func (*MetaMember) ProtoMessage()    {}
func (*MetaMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{3}
}
func (m *MetaMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetaMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetaMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetaMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetaMember.Merge(m, src)
}
func (m *MetaMember) XXX_Size() int {
	return m.XSize()
}
func (m *MetaMember) XXX_DiscardUnknown() {
	xxx_messageInfo_MetaMember.DiscardUnknown(m)
}

var xxx_messageInfo_MetaMember proto.InternalMessageInfo

type Runner struct {
	Id              uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ListenPeerURL   string `protobuf:"bytes,2,opt,name=listenPeerURL,proto3" json:"listenPeerURL,omitempty"`
	ListenClientURL string `protobuf:"bytes,3,opt,name=listenClientURL,proto3" json:"listenClientURL,omitempty"`
	HeartbeatMs     int64  `protobuf:"varint,4,opt,name=heartbeatMs,proto3" json:"heartbeatMs,omitempty"`
	Hostname        string `protobuf:"bytes,5,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Cpu             uint64 `protobuf:"varint,6,opt,name=cpu,proto3" json:"cpu,omitempty"`
	Memory          uint64 `protobuf:"varint,7,opt,name=memory,proto3" json:"memory,omitempty"`
	Version         string `protobuf:"bytes,8,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Runner) Reset()         { *m = Runner{} }
func (m *Runner) String() string { return proto.CompactTextString(m) }
func (*Runner) ProtoMessage()    {}
func (*Runner) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{4}
}
func (m *Runner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Runner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Runner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Runner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Runner.Merge(m, src)
}
func (m *Runner) XXX_Size() int {
	return m.XSize()
}
func (m *Runner) XXX_DiscardUnknown() {
	xxx_messageInfo_Runner.DiscardUnknown(m)
}

var xxx_messageInfo_Runner proto.InternalMessageInfo

type RunnerStat struct {
	Id            uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	CpuPer        float64  `protobuf:"fixed64,11,opt,name=cpuPer,proto3" json:"cpuPer,omitempty"`
	MemoryPer     float64  `protobuf:"fixed64,12,opt,name=memoryPer,proto3" json:"memoryPer,omitempty"`
	Regions       []uint64 `protobuf:"varint,21,rep,packed,name=regions,proto3" json:"regions,omitempty"`
	Leaders       []string `protobuf:"bytes,22,rep,name=leaders,proto3" json:"leaders,omitempty"`
	Definitions   uint64   `protobuf:"varint,23,opt,name=definitions,proto3" json:"definitions,omitempty"`
	BpmnProcesses uint64   `protobuf:"varint,24,opt,name=bpmnProcesses,proto3" json:"bpmnProcesses,omitempty"`
	BpmnEvents    uint64   `protobuf:"varint,25,opt,name=bpmnEvents,proto3" json:"bpmnEvents,omitempty"`
	BpmnTasks     uint64   `protobuf:"varint,26,opt,name=bpmnTasks,proto3" json:"bpmnTasks,omitempty"`
	State         State    `protobuf:"varint,101,opt,name=state,proto3,enum=olivepb.State" json:"state,omitempty"`
	Error         string   `protobuf:"bytes,102,opt,name=error,proto3" json:"error,omitempty"`
	Timestamp     int64    `protobuf:"varint,103,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *RunnerStat) Reset()         { *m = RunnerStat{} }
func (m *RunnerStat) String() string { return proto.CompactTextString(m) }
func (*RunnerStat) ProtoMessage()    {}
func (*RunnerStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{5}
}
func (m *RunnerStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunnerStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunnerStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunnerStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunnerStat.Merge(m, src)
}
func (m *RunnerStat) XXX_Size() int {
	return m.XSize()
}
func (m *RunnerStat) XXX_DiscardUnknown() {
	xxx_messageInfo_RunnerStat.DiscardUnknown(m)
}

var xxx_messageInfo_RunnerStat proto.InternalMessageInfo

type Region struct {
	Id           uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	DeploymentId uint64 `protobuf:"varint,3,opt,name=deploymentId,proto3" json:"deploymentId,omitempty"`
	// replicaID => runnerId
	Members      map[uint64]uint64         `protobuf:"bytes,4,rep,name=members,proto3" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Replicas     map[uint64]*RegionReplica `protobuf:"bytes,5,rep,name=replicas,proto3" json:"replicas,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ElectionRTT  uint64                    `protobuf:"varint,6,opt,name=electionRTT,proto3" json:"electionRTT,omitempty"`
	HeartbeatRTT uint64                    `protobuf:"varint,7,opt,name=heartbeatRTT,proto3" json:"heartbeatRTT,omitempty"`
	Leader       uint64                    `protobuf:"varint,8,opt,name=leader,proto3" json:"leader,omitempty"`
	Definitions  uint64                    `protobuf:"varint,11,opt,name=definitions,proto3" json:"definitions,omitempty"`
	Rev          int64                     `protobuf:"varint,12,opt,name=rev,proto3" json:"rev,omitempty"`
	State        State                     `protobuf:"varint,21,opt,name=state,proto3,enum=olivepb.State" json:"state,omitempty"`
	Error        string                    `protobuf:"bytes,22,opt,name=error,proto3" json:"error,omitempty"`
	Timestamp    int64                     `protobuf:"varint,23,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *Region) Reset()         { *m = Region{} }
func (m *Region) String() string { return proto.CompactTextString(m) }
func (*Region) ProtoMessage()    {}
func (*Region) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{6}
}
func (m *Region) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Region) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Region.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Region) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Region.Merge(m, src)
}
func (m *Region) XXX_Size() int {
	return m.XSize()
}
func (m *Region) XXX_DiscardUnknown() {
	xxx_messageInfo_Region.DiscardUnknown(m)
}

var xxx_messageInfo_Region proto.InternalMessageInfo

type RegionReplica struct {
	Id          uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Runner      uint64 `protobuf:"varint,2,opt,name=runner,proto3" json:"runner,omitempty"`
	Region      uint64 `protobuf:"varint,3,opt,name=region,proto3" json:"region,omitempty"`
	RaftAddress string `protobuf:"bytes,4,opt,name=raftAddress,proto3" json:"raftAddress,omitempty"`
	IsNonVoting bool   `protobuf:"varint,5,opt,name=isNonVoting,proto3" json:"isNonVoting,omitempty"`
	IsWitness   bool   `protobuf:"varint,6,opt,name=isWitness,proto3" json:"isWitness,omitempty"`
	IsJoin      bool   `protobuf:"varint,7,opt,name=isJoin,proto3" json:"isJoin,omitempty"`
}

func (m *RegionReplica) Reset()         { *m = RegionReplica{} }
func (m *RegionReplica) String() string { return proto.CompactTextString(m) }
func (*RegionReplica) ProtoMessage()    {}
func (*RegionReplica) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{7}
}
func (m *RegionReplica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionReplica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionReplica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionReplica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionReplica.Merge(m, src)
}
func (m *RegionReplica) XXX_Size() int {
	return m.XSize()
}
func (m *RegionReplica) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionReplica.DiscardUnknown(m)
}

var xxx_messageInfo_RegionReplica proto.InternalMessageInfo

type RegionStat struct {
	Id                 uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Leader             uint64 `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
	Term               uint64 `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	Replicas           int32  `protobuf:"varint,4,opt,name=replicas,proto3" json:"replicas,omitempty"`
	Definitions        uint64 `protobuf:"varint,11,opt,name=definitions,proto3" json:"definitions,omitempty"`
	RunningDefinitions uint64 `protobuf:"varint,12,opt,name=runningDefinitions,proto3" json:"runningDefinitions,omitempty"`
	BpmnProcesses      uint64 `protobuf:"varint,13,opt,name=bpmnProcesses,proto3" json:"bpmnProcesses,omitempty"`
	BpmnEvents         uint64 `protobuf:"varint,14,opt,name=bpmnEvents,proto3" json:"bpmnEvents,omitempty"`
	BpmnTasks          uint64 `protobuf:"varint,15,opt,name=bpmnTasks,proto3" json:"bpmnTasks,omitempty"`
	State              State  `protobuf:"varint,101,opt,name=state,proto3,enum=olivepb.State" json:"state,omitempty"`
	Error              string `protobuf:"bytes,102,opt,name=error,proto3" json:"error,omitempty"`
	Timestamp          int64  `protobuf:"varint,103,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *RegionStat) Reset()         { *m = RegionStat{} }
func (m *RegionStat) String() string { return proto.CompactTextString(m) }
func (*RegionStat) ProtoMessage()    {}
func (*RegionStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{8}
}
func (m *RegionStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegionStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegionStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegionStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegionStat.Merge(m, src)
}
func (m *RegionStat) XXX_Size() int {
	return m.XSize()
}
func (m *RegionStat) XXX_DiscardUnknown() {
	xxx_messageInfo_RegionStat.DiscardUnknown(m)
}

var xxx_messageInfo_RegionStat proto.InternalMessageInfo

type Definition struct {
	Header  *OliveHeader `protobuf:"bytes,100,opt,name=header,proto3" json:"header,omitempty"`
	Id      string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name    string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Content []byte       `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Version uint64       `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Definition) Reset()         { *m = Definition{} }
func (m *Definition) String() string { return proto.CompactTextString(m) }
func (*Definition) ProtoMessage()    {}
func (*Definition) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{9}
}
func (m *Definition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Definition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Definition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Definition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Definition.Merge(m, src)
}
func (m *Definition) XXX_Size() int {
	return m.XSize()
}
func (m *Definition) XXX_DiscardUnknown() {
	xxx_messageInfo_Definition.DiscardUnknown(m)
}

var xxx_messageInfo_Definition proto.InternalMessageInfo

type DefinitionMeta struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Version  uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Region   uint64 `protobuf:"varint,3,opt,name=region,proto3" json:"region,omitempty"`
	StartRev int64  `protobuf:"varint,4,opt,name=startRev,proto3" json:"startRev,omitempty"`
	EndRev   int64  `protobuf:"varint,5,opt,name=EndRev,proto3" json:"EndRev,omitempty"`
}

func (m *DefinitionMeta) Reset()         { *m = DefinitionMeta{} }
func (m *DefinitionMeta) String() string { return proto.CompactTextString(m) }
func (*DefinitionMeta) ProtoMessage()    {}
func (*DefinitionMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{10}
}
func (m *DefinitionMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefinitionMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DefinitionMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DefinitionMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefinitionMeta.Merge(m, src)
}
func (m *DefinitionMeta) XXX_Size() int {
	return m.XSize()
}
func (m *DefinitionMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_DefinitionMeta.DiscardUnknown(m)
}

var xxx_messageInfo_DefinitionMeta proto.InternalMessageInfo

type ProcessInstance struct {
	Header     *OliveHeader `protobuf:"bytes,100,opt,name=header,proto3" json:"header,omitempty"`
	Definition string       `protobuf:"bytes,1,opt,name=definition,proto3" json:"definition,omitempty"`
}

func (m *ProcessInstance) Reset()         { *m = ProcessInstance{} }
func (m *ProcessInstance) String() string { return proto.CompactTextString(m) }
func (*ProcessInstance) ProtoMessage()    {}
func (*ProcessInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_30d67365becb7733, []int{11}
}
func (m *ProcessInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInstance.Merge(m, src)
}
func (m *ProcessInstance) XXX_Size() int {
	return m.XSize()
}
func (m *ProcessInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInstance.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInstance proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("olivepb.State", State_name, State_value)
	proto.RegisterType((*OliveHeader)(nil), "olivepb.OliveHeader")
	proto.RegisterType((*ResponseHeader)(nil), "olivepb.ResponseHeader")
	proto.RegisterType((*Meta)(nil), "olivepb.Meta")
	proto.RegisterType((*MetaMember)(nil), "olivepb.MetaMember")
	proto.RegisterType((*Runner)(nil), "olivepb.Runner")
	proto.RegisterType((*RunnerStat)(nil), "olivepb.RunnerStat")
	proto.RegisterType((*Region)(nil), "olivepb.Region")
	proto.RegisterMapType((map[uint64]uint64)(nil), "olivepb.Region.MembersEntry")
	proto.RegisterMapType((map[uint64]*RegionReplica)(nil), "olivepb.Region.ReplicasEntry")
	proto.RegisterType((*RegionReplica)(nil), "olivepb.RegionReplica")
	proto.RegisterType((*RegionStat)(nil), "olivepb.RegionStat")
	proto.RegisterType((*Definition)(nil), "olivepb.Definition")
	proto.RegisterType((*DefinitionMeta)(nil), "olivepb.DefinitionMeta")
	proto.RegisterType((*ProcessInstance)(nil), "olivepb.ProcessInstance")
}

func init() {
	proto.RegisterFile("github.com/olive-io/olive/api/olivepb/internal.proto", fileDescriptor_30d67365becb7733)
}

var fileDescriptor_30d67365becb7733 = []byte{
	// 1091 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xcf, 0xfa, 0xb7, 0x9f, 0x5d, 0x27, 0x9a, 0x6f, 0xea, 0xce, 0xd7, 0xb4, 0x96, 0x65, 0xf5,
	0x60, 0xa1, 0xc6, 0x91, 0x02, 0x42, 0xa5, 0x9c, 0x0a, 0x44, 0x22, 0x94, 0xb4, 0xd1, 0x34, 0x05,
	0xc4, 0x25, 0x5a, 0x7b, 0x5f, 0x9c, 0x51, 0xbc, 0xb3, 0xab, 0x99, 0xb1, 0x51, 0xfe, 0x01, 0xce,
	0x88, 0xbf, 0x88, 0x63, 0xb9, 0xf5, 0xc8, 0x11, 0x12, 0x89, 0x03, 0x67, 0xfe, 0x00, 0x34, 0x3f,
	0xbc, 0x5e, 0x3b, 0x09, 0x2d, 0x17, 0x4e, 0x3b, 0xef, 0xf3, 0x7e, 0xcc, 0x9b, 0xf7, 0x79, 0xf3,
	0x66, 0xe1, 0xc3, 0x09, 0xd7, 0x67, 0xb3, 0xd1, 0x70, 0x9c, 0xc4, 0xbb, 0xc9, 0x94, 0xcf, 0x71,
	0x87, 0x27, 0x6e, 0xb1, 0x1b, 0xa6, 0xdc, 0xad, 0xd2, 0xd1, 0x2e, 0x17, 0x1a, 0xa5, 0x08, 0xa7,
	0xc3, 0x54, 0x26, 0x3a, 0x21, 0x55, 0x8f, 0x77, 0xb6, 0x27, 0xc9, 0x24, 0xb1, 0xd8, 0xae, 0x59,
	0x39, 0x75, 0xff, 0x05, 0x34, 0x5e, 0x18, 0x83, 0x2f, 0x30, 0x8c, 0x50, 0x92, 0x36, 0x54, 0xe4,
	0x4c, 0x08, 0x94, 0x34, 0xe8, 0x05, 0x83, 0x12, 0xf3, 0x92, 0xc5, 0x71, 0xc2, 0x13, 0x41, 0x0b,
	0x1e, 0xb7, 0x12, 0xd9, 0x82, 0xa2, 0xc4, 0x39, 0x2d, 0xf6, 0x82, 0x41, 0x91, 0x99, 0x65, 0x9f,
	0x43, 0x8b, 0xa1, 0x4a, 0x13, 0xa1, 0x16, 0x31, 0x1f, 0x00, 0x8c, 0xa7, 0x33, 0xa5, 0x51, 0x9e,
	0xf0, 0xc8, 0xc7, 0xad, 0x7b, 0xe4, 0x20, 0x22, 0xef, 0x41, 0x3d, 0xc6, 0x78, 0xe4, 0xb4, 0x2e,
	0x7a, 0xcd, 0x01, 0x4e, 0x29, 0xc3, 0x53, 0x7d, 0xa2, 0x51, 0xc6, 0x76, 0x97, 0x12, 0xab, 0x19,
	0xe0, 0x18, 0x65, 0xdc, 0x3f, 0x87, 0xd2, 0x21, 0xea, 0x90, 0xdc, 0x87, 0x65, 0xb8, 0xeb, 0xf1,
	0xdb, 0x50, 0x99, 0xda, 0x44, 0x16, 0xa9, 0x3b, 0x89, 0xec, 0x40, 0xd5, 0x6d, 0xa3, 0x68, 0xb1,
	0x57, 0x1c, 0x34, 0xf6, 0xfe, 0x37, 0xf4, 0xa5, 0x1a, 0x9a, 0xa8, 0x87, 0x56, 0xc7, 0x16, 0x36,
	0xfd, 0x6f, 0x01, 0x96, 0x30, 0x69, 0x41, 0x21, 0x3b, 0x4b, 0x81, 0x47, 0xa4, 0x6b, 0xce, 0xc8,
	0x51, 0xe8, 0x57, 0xec, 0x2b, 0x45, 0x0b, 0xbd, 0xe2, 0xa0, 0xce, 0x72, 0x08, 0xe9, 0x40, 0x2d,
	0x45, 0x94, 0x56, 0x5b, 0xb4, 0xda, 0x4c, 0xee, 0xff, 0x19, 0x40, 0x85, 0xb9, 0x32, 0xaf, 0x87,
	0x7d, 0x08, 0x77, 0xa6, 0x5c, 0x69, 0x14, 0x47, 0xce, 0xd8, 0x1e, 0xa1, 0xce, 0x56, 0x41, 0x32,
	0x80, 0x4d, 0x07, 0x7c, 0xb6, 0xd8, 0xd0, 0x96, 0xaa, 0xce, 0xd6, 0x61, 0xd2, 0x83, 0xc6, 0x19,
	0x86, 0x52, 0x8f, 0x30, 0xd4, 0x87, 0x8a, 0x96, 0x2c, 0x6d, 0x79, 0xc8, 0x24, 0x7a, 0x96, 0x28,
	0x2d, 0xc2, 0x18, 0x69, 0xd9, 0x06, 0xc9, 0x64, 0x43, 0xf6, 0x38, 0x9d, 0xd1, 0x8a, 0x4d, 0xcf,
	0x2c, 0x4d, 0x6d, 0x63, 0x8c, 0x13, 0x79, 0x41, 0xab, 0xae, 0xb6, 0x4e, 0x22, 0x14, 0xaa, 0x73,
	0x94, 0xca, 0xf4, 0x4b, 0xcd, 0x06, 0x59, 0x88, 0xfd, 0x3f, 0x0a, 0x00, 0xee, 0xb0, 0x2f, 0x75,
	0xa8, 0xaf, 0x1d, 0xb8, 0x0d, 0x95, 0x71, 0x3a, 0x3b, 0x42, 0x49, 0x1b, 0xbd, 0x60, 0x10, 0x30,
	0x2f, 0x19, 0x8a, 0x5d, 0x68, 0xa3, 0x6a, 0x5a, 0xd5, 0x12, 0x30, 0xdb, 0xb9, 0x7e, 0x54, 0xf4,
	0x6e, 0xaf, 0x38, 0x28, 0xb1, 0x85, 0x68, 0x34, 0x8e, 0x6e, 0x45, 0xdb, 0xb6, 0xec, 0x0b, 0xd1,
	0x94, 0x22, 0xc2, 0x53, 0x2e, 0xb8, 0xb6, 0x7e, 0xf7, 0x6c, 0x0a, 0x79, 0xc8, 0x14, 0x7f, 0x94,
	0xc6, 0xe2, 0x48, 0x26, 0x63, 0x54, 0x0a, 0x15, 0xa5, 0xd6, 0x66, 0x15, 0x34, 0xcc, 0x1b, 0x60,
	0x7f, 0x8e, 0x42, 0x2b, 0xfa, 0x7f, 0x6b, 0x92, 0x43, 0x4c, 0xe6, 0x46, 0x3a, 0x0e, 0xd5, 0xb9,
	0xa2, 0x1d, 0xd7, 0x9c, 0x19, 0x40, 0x1e, 0x42, 0x59, 0xe9, 0x50, 0x23, 0xc5, 0x5e, 0x30, 0x68,
	0xed, 0xb5, 0xb2, 0x16, 0x34, 0xd5, 0x41, 0xe6, 0x94, 0x64, 0x1b, 0xca, 0x28, 0x65, 0x22, 0xe9,
	0xa9, 0x2d, 0xa6, 0x13, 0x4c, 0x64, 0xcd, 0x63, 0x54, 0x3a, 0x8c, 0x53, 0x3a, 0xb1, 0x54, 0x2e,
	0x81, 0xfe, 0xcf, 0x25, 0xa8, 0x30, 0x77, 0x49, 0xd7, 0x8b, 0x4c, 0xa0, 0x64, 0xf9, 0x75, 0xcd,
	0x64, 0xd7, 0xa4, 0x0f, 0xcd, 0x08, 0xd3, 0x69, 0x72, 0x11, 0xa3, 0xd0, 0x07, 0x91, 0xbf, 0x6b,
	0x2b, 0x18, 0xf9, 0x68, 0x79, 0x63, 0x4a, 0xf6, 0xc6, 0xdc, 0xcf, 0xd2, 0x75, 0x3b, 0x0d, 0xdd,
	0xed, 0x50, 0xfb, 0x42, 0xcb, 0x8b, 0xec, 0xea, 0x90, 0x8f, 0xa1, 0x26, 0x31, 0x9d, 0xf2, 0x71,
	0xa8, 0x68, 0xd9, 0x3a, 0x3e, 0x58, 0x77, 0x64, 0x5e, 0xef, 0x3c, 0x33, 0x73, 0xc3, 0x12, 0x4e,
	0x71, 0x6c, 0x08, 0x61, 0xc7, 0xc7, 0xbe, 0xf5, 0xf2, 0x90, 0x49, 0x3c, 0xeb, 0x5f, 0x63, 0xe2,
	0x1a, 0x71, 0x05, 0xcb, 0x8d, 0x80, 0xda, 0xca, 0x08, 0x58, 0xeb, 0x81, 0xc6, 0xf5, 0x1e, 0xf0,
	0xf3, 0xad, 0x99, 0xcd, 0xb7, 0x25, 0x63, 0x77, 0xdf, 0x89, 0xb1, 0xf6, 0xad, 0x8c, 0xdd, 0x5b,
	0x63, 0xac, 0xf3, 0x04, 0x9a, 0xf9, 0xfa, 0x99, 0xbd, 0xcf, 0xf1, 0xc2, 0xf3, 0x66, 0x96, 0x26,
	0xea, 0x3c, 0x9c, 0xce, 0xd0, 0x4f, 0x32, 0x27, 0x3c, 0x29, 0x3c, 0x0e, 0x3a, 0x2f, 0xe1, 0xce,
	0x4a, 0x09, 0x6f, 0x70, 0x7e, 0x94, 0x77, 0x6e, 0xec, 0xb5, 0xd7, 0x28, 0xf0, 0xee, 0xb9, 0xa0,
	0xfd, 0x5f, 0x02, 0x13, 0x35, 0xa7, 0xbc, 0xe9, 0xba, 0xfa, 0xe7, 0xa2, 0x70, 0xcb, 0x73, 0x51,
	0x5c, 0x79, 0x2e, 0x7a, 0xd0, 0x30, 0xd3, 0xfb, 0x69, 0x14, 0x49, 0x54, 0x6e, 0xfe, 0xd4, 0x59,
	0x1e, 0x32, 0x16, 0x5c, 0x3d, 0x4f, 0xc4, 0xd7, 0x89, 0xe6, 0x62, 0x62, 0x47, 0x50, 0x8d, 0xe5,
	0x21, 0x53, 0x44, 0xae, 0xbe, 0xe1, 0x5a, 0x98, 0x08, 0x15, 0xab, 0x5f, 0x02, 0x66, 0x67, 0xae,
	0xbe, 0x4c, 0xb8, 0xb0, 0x8d, 0x50, 0x63, 0x5e, 0xea, 0xff, 0x65, 0xe6, 0x8e, 0x4d, 0xe2, 0xb6,
	0xb9, 0x73, 0xe3, 0x23, 0x41, 0xa0, 0x94, 0x7b, 0x7a, 0xec, 0xda, 0x8c, 0xc8, 0xac, 0x9d, 0xcd,
	0x09, 0xca, 0xab, 0xfd, 0xfa, 0x96, 0x8e, 0x1a, 0x02, 0x31, 0x45, 0xe2, 0x62, 0xf2, 0x79, 0xce,
	0xb0, 0x69, 0x0d, 0x6f, 0xd0, 0x5c, 0x9f, 0x42, 0x77, 0xde, 0x3e, 0x85, 0x5a, 0xff, 0x3c, 0x85,
	0x36, 0xff, 0xbb, 0x29, 0xf4, 0x53, 0x00, 0xb0, 0x3c, 0x0d, 0x79, 0x04, 0x95, 0x33, 0x57, 0xe6,
	0xc8, 0x36, 0xe1, 0x76, 0xb6, 0x53, 0xee, 0x27, 0x84, 0x79, 0x9b, 0x1c, 0x49, 0xf5, 0x5b, 0xe7,
	0x16, 0x85, 0xea, 0x38, 0x11, 0x1a, 0x85, 0xb6, 0x1c, 0x35, 0xd9, 0x42, 0xcc, 0xbf, 0x41, 0x25,
	0x7b, 0xe0, 0xec, 0x0d, 0xfa, 0x21, 0x80, 0xd6, 0x32, 0x29, 0xfb, 0x0b, 0xb1, 0xbe, 0x55, 0xce,
	0xb9, 0xb0, 0xe2, 0x7c, 0x6b, 0x6b, 0x77, 0xa0, 0xa6, 0x74, 0x28, 0x35, 0xc3, 0xb9, 0x7f, 0x57,
	0x33, 0xd9, 0xf8, 0xec, 0x8b, 0xc8, 0x68, 0xca, 0x56, 0xe3, 0xa5, 0xfe, 0x09, 0x6c, 0x7a, 0x0a,
	0x0f, 0x84, 0xd2, 0xa1, 0x18, 0xe3, 0xbf, 0xac, 0x50, 0x17, 0x60, 0xd9, 0x5b, 0x3e, 0xfd, 0x1c,
	0xf2, 0xfe, 0x63, 0x28, 0x5b, 0x0a, 0x49, 0x03, 0xaa, 0xaf, 0xc4, 0x33, 0x91, 0x7c, 0x2f, 0xb6,
	0x36, 0x48, 0x1d, 0xca, 0x0c, 0xc3, 0xe8, 0x62, 0x2b, 0x20, 0x4d, 0xa8, 0x3d, 0x4f, 0xb4, 0x93,
	0x0a, 0x46, 0xf1, 0x74, 0x1a, 0xca, 0x78, 0xab, 0xf8, 0xe9, 0xb3, 0xd7, 0xbf, 0x77, 0x37, 0x5e,
	0x5f, 0x76, 0x83, 0x37, 0x97, 0xdd, 0xe0, 0xb7, 0xcb, 0x6e, 0xf0, 0xe3, 0x55, 0x77, 0xe3, 0xcd,
	0x55, 0x77, 0xe3, 0xd7, 0xab, 0xee, 0xc6, 0x77, 0x3b, 0xef, 0xf4, 0x2b, 0xfa, 0x89, 0xff, 0x8e,
	0x2a, 0xf6, 0x5f, 0xf3, 0x83, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x95, 0xaa, 0xc8, 0xcf, 0xc2,
	0x0a, 0x00, 0x00,
}

func (m *OliveHeader) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Runner != 0 {
		n += 1 + sovInternal(uint64(m.Runner))
	}
	if m.Region != 0 {
		n += 1 + sovInternal(uint64(m.Region))
	}
	if m.Rev != 0 {
		n += 1 + sovInternal(uint64(m.Rev))
	}
	return n
}

func (m *ResponseHeader) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovInternal(uint64(m.ClusterId))
	}
	if m.MemberId != 0 {
		n += 1 + sovInternal(uint64(m.MemberId))
	}
	if m.RaftTerm != 0 {
		n += 1 + sovInternal(uint64(m.RaftTerm))
	}
	return n
}

func (m *Meta) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovInternal(uint64(m.ClusterId))
	}
	if m.Leader != 0 {
		n += 1 + sovInternal(uint64(m.Leader))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.XSize()
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	return n
}

func (m *MetaMember) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	if len(m.ClientURLs) > 0 {
		for _, s := range m.ClientURLs {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	if len(m.PeerURLs) > 0 {
		for _, s := range m.PeerURLs {
			l = len(s)
			n += 1 + l + sovInternal(uint64(l))
		}
	}
	return n
}

func (m *Runner) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	l = len(m.ListenPeerURL)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.ListenClientURL)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.HeartbeatMs != 0 {
		n += 1 + sovInternal(uint64(m.HeartbeatMs))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Cpu != 0 {
		n += 1 + sovInternal(uint64(m.Cpu))
	}
	if m.Memory != 0 {
		n += 1 + sovInternal(uint64(m.Memory))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func (m *RunnerStat) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	if m.CpuPer != 0 {
		n += 9
	}
	if m.MemoryPer != 0 {
		n += 9
	}
	if len(m.Regions) > 0 {
		l = 0
		for _, e := range m.Regions {
			l += sovInternal(uint64(e))
		}
		n += 2 + sovInternal(uint64(l)) + l
	}
	if len(m.Leaders) > 0 {
		for _, s := range m.Leaders {
			l = len(s)
			n += 2 + l + sovInternal(uint64(l))
		}
	}
	if m.Definitions != 0 {
		n += 2 + sovInternal(uint64(m.Definitions))
	}
	if m.BpmnProcesses != 0 {
		n += 2 + sovInternal(uint64(m.BpmnProcesses))
	}
	if m.BpmnEvents != 0 {
		n += 2 + sovInternal(uint64(m.BpmnEvents))
	}
	if m.BpmnTasks != 0 {
		n += 2 + sovInternal(uint64(m.BpmnTasks))
	}
	if m.State != 0 {
		n += 2 + sovInternal(uint64(m.State))
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 2 + sovInternal(uint64(m.Timestamp))
	}
	return n
}

func (m *Region) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.DeploymentId != 0 {
		n += 1 + sovInternal(uint64(m.DeploymentId))
	}
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			mapEntrySize := 1 + sovInternal(uint64(k)) + 1 + sovInternal(uint64(v))
			n += mapEntrySize + 1 + sovInternal(uint64(mapEntrySize))
		}
	}
	if len(m.Replicas) > 0 {
		for k, v := range m.Replicas {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovInternal(uint64(l))
			}
			mapEntrySize := 1 + sovInternal(uint64(k)) + l
			n += mapEntrySize + 1 + sovInternal(uint64(mapEntrySize))
		}
	}
	if m.ElectionRTT != 0 {
		n += 1 + sovInternal(uint64(m.ElectionRTT))
	}
	if m.HeartbeatRTT != 0 {
		n += 1 + sovInternal(uint64(m.HeartbeatRTT))
	}
	if m.Leader != 0 {
		n += 1 + sovInternal(uint64(m.Leader))
	}
	if m.Definitions != 0 {
		n += 1 + sovInternal(uint64(m.Definitions))
	}
	if m.Rev != 0 {
		n += 1 + sovInternal(uint64(m.Rev))
	}
	if m.State != 0 {
		n += 2 + sovInternal(uint64(m.State))
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 2 + sovInternal(uint64(m.Timestamp))
	}
	return n
}

func (m *RegionReplica) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	if m.Runner != 0 {
		n += 1 + sovInternal(uint64(m.Runner))
	}
	if m.Region != 0 {
		n += 1 + sovInternal(uint64(m.Region))
	}
	l = len(m.RaftAddress)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.IsNonVoting {
		n += 2
	}
	if m.IsWitness {
		n += 2
	}
	if m.IsJoin {
		n += 2
	}
	return n
}

func (m *RegionStat) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovInternal(uint64(m.Id))
	}
	if m.Leader != 0 {
		n += 1 + sovInternal(uint64(m.Leader))
	}
	if m.Term != 0 {
		n += 1 + sovInternal(uint64(m.Term))
	}
	if m.Replicas != 0 {
		n += 1 + sovInternal(uint64(m.Replicas))
	}
	if m.Definitions != 0 {
		n += 1 + sovInternal(uint64(m.Definitions))
	}
	if m.RunningDefinitions != 0 {
		n += 1 + sovInternal(uint64(m.RunningDefinitions))
	}
	if m.BpmnProcesses != 0 {
		n += 1 + sovInternal(uint64(m.BpmnProcesses))
	}
	if m.BpmnEvents != 0 {
		n += 1 + sovInternal(uint64(m.BpmnEvents))
	}
	if m.BpmnTasks != 0 {
		n += 1 + sovInternal(uint64(m.BpmnTasks))
	}
	if m.State != 0 {
		n += 2 + sovInternal(uint64(m.State))
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovInternal(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 2 + sovInternal(uint64(m.Timestamp))
	}
	return n
}

func (m *Definition) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.XSize()
		n += 2 + l + sovInternal(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovInternal(uint64(m.Version))
	}
	return n
}

func (m *DefinitionMeta) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovInternal(uint64(m.Version))
	}
	if m.Region != 0 {
		n += 1 + sovInternal(uint64(m.Region))
	}
	if m.StartRev != 0 {
		n += 1 + sovInternal(uint64(m.StartRev))
	}
	if m.EndRev != 0 {
		n += 1 + sovInternal(uint64(m.EndRev))
	}
	return n
}

func (m *ProcessInstance) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.XSize()
		n += 2 + l + sovInternal(uint64(l))
	}
	l = len(m.Definition)
	if l > 0 {
		n += 1 + l + sovInternal(uint64(l))
	}
	return n
}

func sovInternal(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func sozInternal(x uint64) (n int) {
	return sovInternal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OliveHeader) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OliveHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OliveHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rev != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Rev))
		i--
		dAtA[i] = 0x18
	}
	if m.Region != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Region))
		i--
		dAtA[i] = 0x10
	}
	if m.Runner != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Runner))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RaftTerm != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.RaftTerm))
		i--
		dAtA[i] = 0x18
	}
	if m.MemberId != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.MemberId))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterId != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Meta) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInternal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Leader != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterId != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.ClusterId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetaMember) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetaMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PeerURLs) > 0 {
		for iNdEx := len(m.PeerURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerURLs[iNdEx])
			copy(dAtA[i:], m.PeerURLs[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.PeerURLs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ClientURLs) > 0 {
		for iNdEx := len(m.ClientURLs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ClientURLs[iNdEx])
			copy(dAtA[i:], m.ClientURLs[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.ClientURLs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Runner) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Runner) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Runner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x42
	}
	if m.Memory != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x38
	}
	if m.Cpu != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x2a
	}
	if m.HeartbeatMs != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.HeartbeatMs))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ListenClientURL) > 0 {
		i -= len(m.ListenClientURL)
		copy(dAtA[i:], m.ListenClientURL)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ListenClientURL)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ListenPeerURL) > 0 {
		i -= len(m.ListenPeerURL)
		copy(dAtA[i:], m.ListenPeerURL)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.ListenPeerURL)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RunnerStat) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunnerStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunnerStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if m.State != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.BpmnTasks != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.BpmnTasks))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.BpmnEvents != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.BpmnEvents))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.BpmnProcesses != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.BpmnProcesses))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.Definitions != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Definitions))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Leaders) > 0 {
		for iNdEx := len(m.Leaders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Leaders[iNdEx])
			copy(dAtA[i:], m.Leaders[iNdEx])
			i = encodeVarintInternal(dAtA, i, uint64(len(m.Leaders[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Regions) > 0 {
		dAtA2 := make([]byte, len(m.Regions)*10)
		var j1 int
		for _, num := range m.Regions {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintInternal(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.MemoryPer != 0 {
		i -= 8
		ebinary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemoryPer))))
		i--
		dAtA[i] = 0x61
	}
	if m.CpuPer != 0 {
		i -= 8
		ebinary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuPer))))
		i--
		dAtA[i] = 0x59
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Region) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Region) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Region) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.State != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Rev != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Rev))
		i--
		dAtA[i] = 0x60
	}
	if m.Definitions != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Definitions))
		i--
		dAtA[i] = 0x58
	}
	if m.Leader != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x40
	}
	if m.HeartbeatRTT != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.HeartbeatRTT))
		i--
		dAtA[i] = 0x38
	}
	if m.ElectionRTT != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.ElectionRTT))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Replicas) > 0 {
		for k := range m.Replicas {
			v := m.Replicas[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintInternal(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintInternal(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintInternal(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			i = encodeVarintInternal(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintInternal(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintInternal(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DeploymentId != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.DeploymentId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionReplica) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionReplica) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionReplica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsJoin {
		i--
		if m.IsJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IsWitness {
		i--
		if m.IsWitness {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IsNonVoting {
		i--
		if m.IsNonVoting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RaftAddress) > 0 {
		i -= len(m.RaftAddress)
		copy(dAtA[i:], m.RaftAddress)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.RaftAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.Region != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Region))
		i--
		dAtA[i] = 0x18
	}
	if m.Runner != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Runner))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegionStat) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegionStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegionStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if m.State != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.BpmnTasks != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.BpmnTasks))
		i--
		dAtA[i] = 0x78
	}
	if m.BpmnEvents != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.BpmnEvents))
		i--
		dAtA[i] = 0x70
	}
	if m.BpmnProcesses != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.BpmnProcesses))
		i--
		dAtA[i] = 0x68
	}
	if m.RunningDefinitions != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.RunningDefinitions))
		i--
		dAtA[i] = 0x60
	}
	if m.Definitions != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Definitions))
		i--
		dAtA[i] = 0x58
	}
	if m.Replicas != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Replicas))
		i--
		dAtA[i] = 0x20
	}
	if m.Term != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x18
	}
	if m.Leader != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Definition) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Definition) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Definition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if m.Version != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DefinitionMeta) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefinitionMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefinitionMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndRev != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.EndRev))
		i--
		dAtA[i] = 0x28
	}
	if m.StartRev != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.StartRev))
		i--
		dAtA[i] = 0x20
	}
	if m.Region != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Region))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintInternal(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInstance) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInternal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Definition) > 0 {
		i -= len(m.Definition)
		copy(dAtA[i:], m.Definition)
		i = encodeVarintInternal(dAtA, i, uint64(len(m.Definition)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintInternal(dAtA []byte, offset int, v uint64) int {
	offset -= sovInternal(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OliveHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OliveHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OliveHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runner", wireType)
			}
			m.Runner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Runner |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			m.Rev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberId", wireType)
			}
			m.MemberId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftTerm", wireType)
			}
			m.RaftTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RaftTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &MetaMember{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientURLs = append(m.ClientURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerURLs = append(m.PeerURLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Runner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Runner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Runner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenPeerURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenPeerURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenClientURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListenClientURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatMs", wireType)
			}
			m.HeartbeatMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunnerStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunnerStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunnerStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPer", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(ebinary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuPer = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPer", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(ebinary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemoryPer = float64(math.Float64frombits(v))
		case 21:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Regions = append(m.Regions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInternal
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInternal
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Regions) == 0 {
					m.Regions = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Regions = append(m.Regions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaders = append(m.Leaders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			m.Definitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Definitions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcesses", wireType)
			}
			m.BpmnProcesses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpmnProcesses |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnEvents", wireType)
			}
			m.BpmnEvents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpmnEvents |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnTasks", wireType)
			}
			m.BpmnTasks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpmnTasks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Region) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Region: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Region: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInternal(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthInternal
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replicas == nil {
				m.Replicas = make(map[uint64]*RegionReplica)
			}
			var mapkey uint64
			var mapvalue *RegionReplica
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInternal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInternal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthInternal
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthInternal
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RegionReplica{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInternal(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthInternal
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Replicas[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionRTT", wireType)
			}
			m.ElectionRTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElectionRTT |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatRTT", wireType)
			}
			m.HeartbeatRTT = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatRTT |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			m.Definitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Definitions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			m.Rev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionReplica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionReplica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionReplica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runner", wireType)
			}
			m.Runner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Runner |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNonVoting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNonVoting = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWitness", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWitness = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsJoin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegionStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegionStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegionStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replicas |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			m.Definitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Definitions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunningDefinitions", wireType)
			}
			m.RunningDefinitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunningDefinitions |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcesses", wireType)
			}
			m.BpmnProcesses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpmnProcesses |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnEvents", wireType)
			}
			m.BpmnEvents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpmnEvents |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnTasks", wireType)
			}
			m.BpmnTasks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BpmnTasks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 103:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Definition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Definition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Definition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &OliveHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefinitionMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefinitionMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefinitionMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartRev", wireType)
			}
			m.StartRev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartRev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndRev", wireType)
			}
			m.EndRev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndRev |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInternal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInternal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &OliveHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInternal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInternal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInternal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInternal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInternal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInternal
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInternal
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInternal
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInternal        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInternal          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInternal = fmt.Errorf("proto: unexpected end of group")
)
